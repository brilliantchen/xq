内存模型
-----------------------------------------------------------------------------------------------------------------------------------
线程私有: 
	程序计数器Program Counter Register.当前线程所执行字节码的行号指示器，线程切换使用
	虚拟机栈Java Stack。Java方法执行的内存模型: 每个方法被执行时会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息.
	    每个方法被调用至返回的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程(VM提供了-Xss来指定线程的最大栈空间, 该参数也直接决定了函数调用的最大深度).
	本地方法栈 Native Method Stack。Java Stack作用类似, 本地方法栈则为Native方法服务
线程共享：
	Java堆 Heap，几乎所有对象实例和数组都要在堆上分配(栈上分配，逃逸分析、标量替换除外)。GC的主要区域，分代回收
		新生代(Eden区、From Survivor区和To Survivor区)和老年代
	方法区 Method Area。常说的永久代(Permanent Generation), 用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。GC要目标是针对常量池的回收和类型的卸载
	
-----------------------------------------------------------------------------------------------------------------------------------
方法区：JVM 的规范
PermGen（永久代）：则是 JVM 规范的一种实现，并且只有 HotSpot 才有 “PermGen space”，JDK 1.8 已移除PermGen
Metaspace（元空间）：JVM 规范的一种实现，JDK1.8
-----------------------------------------------------------------------------------------------------------------------------------
Metaspace（元空间） 
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：元空间的内存管理由元空间虚拟机来完成
-XX:MetaspaceSize，初始空间大小
-XX:MaxMetaspaceSize，最大空间，默认是没有限制的。
GC属性：
-XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集
-XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集

PermGen转换Metaspace原因
1、字符串存在永久代中，容易出现性能问题和内存溢出。
2、类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
3、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。
4、Oracle 可能会将HotSpot 与 JRockit 合二为一。
-----------------------------------------------------------------------------------------------------------------------------------
垃圾回收
1.如何定义垃圾
	1.引用计数（但是无法解决循环引用的问题）
	2.可达性分析

2.判断对象可以回收的
	显示的把某个引用置位NULL或者指向别的对象
	局部引用指向的对象
	弱引用关联的对象

3.垃圾回收的方法
	Mark-Sweep标记-清除算法，这种方法优点就是减少停顿时间，但是缺点是会造成内存碎片。
	Copying复制算法，对象从一个地方拷贝到另一个地方，因此适合大量对象回收的场景。新生代
	Mark-Compact标记-整理算法，这种方法可以解决内存碎片问题，但是会增加停顿时间。
	
Generational Collection 分代收集

新生代(Young Generation)：用于存放新创建的对象，采用复制回收方法，如果在s0和s1之间复制一定次数后，转移到年老代中，每次GC后age加1。这里的垃圾回收叫做minor GC;
	Eden:s0:s1 8:1:1
年老代(Old Generation)：这些对象垃圾回收的频率较低，采用的标记整理方法，这里的垃圾回收叫做 major GC。
永久代(Permanent Generation)：存放Java本身的一些数据，当类不再使用时，也会被回收。
	


