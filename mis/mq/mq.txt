1.消息的顺序问题
2.消息的重复问题
3.事务消息
4.消息存储


消息的顺序：
	比如修改订单状态，同一个OrderId 同一个队列
	消息m1， m2 通过一个mqserver发送
	避免网络延迟等问题，当m1响应成功再发送m2
	m1消费成功，响应失败，m1会重发（存在消息重复问题）

消息的重复：
	消费端处理消息的业务逻辑保持幂等性
	保证每条消息都有唯一编号且保证消息处理成功与去重表的日志同时出现
	
事务消息：大事务 = 小事务 + 异步
	事务就可以分解成如下两个小事务
	执行本地事务（Bob账户扣款）和发送异步消息应该保证同时成功或者同时失败，也就是扣款成功了，发送消息一定要成功，如果扣款失败了，就不能再发送消息。
	（先扣款还是先发送消息问题）直接将发消息放到Bob扣款的事务中去，如果发送失败，抛出异常，事务回滚


RocketMQ最佳实践

一、Producer最佳实践

1、一个应用尽可能用一个 Topic，消息子类型用 tags 来标识，tags 可以由应用自由设置。只有发送消息设置了tags，消费方在订阅消息时，才可以利用 tags 在 broker 做消息过滤。
2、每个消息在业务层面的唯一标识码，要设置到 keys 字段，方便将来定位消息丢失问题。由于是哈希索引，请务必保证 key 尽可能唯一，这样可以避免潜在的哈希冲突。
3、消息发送成功或者失败，要打印消息日志，务必要打印 sendresult 和 key 字段。
4、对于消息不可丢失应用，务必要有消息重发机制。例如：消息发送失败，存储到数据库，能有定时程序尝试重发或者人工触发重发。
5、某些应用如果不关注消息是否发送成功，请直接使用sendOneWay方法发送消息。

二、Consumer最佳实践

1、消费过程要做到幂等（即消费端去重）
2、尽量使用批量方式消费方式，可以很大程度上提高消费吞吐量。
3、优化每条消息消费过程


	      ActiveMQ	 RocketMq Kafaka
	
顺序	  N        Y         ?
过滤去重：N        Y
回溯消费  N        Y
	
