<div>
  ACID

  事物：锁和并发的结合体

  原子性：事务对外而言就是一个原子(一步操作)，要么执行成功，要么失败。
  一致性：()happen before)一个事务单元结束后，数据才可见，数据不会丢失。对于外界而言，数据不会被读到中间状态。
  隔离性：引申-数据库隔离级别：SQL破坏一致性92标准
	  排它锁 - 序列化读写(serializable)
	  读写锁-
	  可重复读(repeatable read)读读并行，
	  读已提交(read committed)读读，读写并行(写读还不可以)
	  读未提交(read uncommitted  ):读读，读写，写读 并行，只有写是穿行的
	  隔离性扩展：
	  快照(snapshot isolation)，针对读多写少的优化
	多版本并发控制mvcc，本质：copy on write  能做到写不阻塞读

  持续性：事务完成以后，该事务对数据的更改就会持久报存在数据库中。
  持久性保证策略：group committed

  U锁-update锁：update set a = a-1 where id =1;
  提前判断事务里有针对某一个数据写，提前把读锁升级为写锁。

  锁类型
  悲观锁：数据本身加锁后，线程就到blocking状态，不会被cup调度
  适合并发争抢严重场景
  乐观锁：适合并发争抢不严重场景
  
  隔离级别：
	脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据
	不可重复读：一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了
	虚读(幻读)： 
		事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
		幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）
	
	① Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。

　　② Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

　　③ Read committed (读已提交)：可避免脏读的发生。

　　④ Read uncommitted (读未提交)：最低级别，任何情况都无法保证。
  
</div>


<div>


</div>