<div>
  InnoDB引擎在加锁的时候，只有通过索引进行检索的时候才会使用行级锁，否则会使用表级锁。

  两个或更多个列上的索引被称作复合索引。
  利用索引中的附加列，您可以缩小搜索的范围，但使用一个具有两列的索引不同于使用两个单独的索引。

  索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，
  因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。
  一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有 必要。

  如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。
  因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。

  索引不触发情况：
   在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，
       否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。

    1.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
      select id from t where num is null
      最好不要给数据库留NULL，尽可能的使用 NOT NULL填充数据库.

    2.应尽量避免在 where 子句中使用 != 或 <> 操作符，否则将引擎放弃使用索引而进行全表扫描。

    3.应尽量避免在 where 子句中使用 or 来连接条件，如果一个字段有索引，一个字段没有索引，将导致引擎放弃使用索引而进行全表扫描，如：
      select id from t where num=10 or Name = 'admin'
      可以这样查询：
      select id from t where num = 10
      union all
      select id from t where Name = 'admin'

    4.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
      不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
      select id from t where num/2 = 100
      应改为:select id from t where num = 100*2

    5.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：
      select id from t where substring(name,1,3) = ’abc’       -–name以abc开头的id
      select id from t where datediff(day,createdate,’2005-11-30′) = 0    -–‘2005-11-30’    --生成的id
      应改为:
      select id from t where name like 'abc%'
      select id from t where createdate >= '2005-11-30' and createdate < '2005-12-1'





</div>
