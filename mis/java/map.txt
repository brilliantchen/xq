-----------------------------------------------------------------------------------------------------------------------------------
HashMap
是数组+链表+红黑树（JDK1.8,链表长度大于8）实现的
int threshold;             // 容量极限 默认12 (capacity*loadFacor) ，越小越快越费内存（越小越容易resize，hash冲突概率小），可以大于1
final float loadFactor;    // 负载因子 0.75
int modCount;              // modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败
int size;                  // 实际存在的键值对数量 
Node[] table               // length默认值是16

public HashMap(int initialCapacity,float loadFactor)
put方法

if table == null || length == 0
	resize
//根据key计算hash值对应的table索引i
if table[i] == null
	tab[i] = newNode(hash, key, value, null)
else
	if key.equals
		//replace替换
	else if p instanceof TreeNode
		//putTreeVal 插入红黑树
	else //链表
		for (int binCount = 0; ; ++binCount) {
			if ((e = p.next) == null) {
				p.next = newNode(hash, key, value, null);
				if (binCount >= TREEIFY_THRESHOLD - 1) // 大于8转化为红黑树
					treeifyBin(tab, hash);
				break;
			}
			if key.equals
				//key 存在直接替换
				break;
			p = e;
		}
if (++size > threshold)
	resize();

-----------------------------------------------------------------------------------------------------------------------------------

哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。
在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上
-----------------------------------------------------------------------------------------------------------------------------------
ConcurrentHashMap具体是怎么实现线程安全的呢，肯定不可能是每个方法加synchronized，那样就变成了HashTable。

从ConcurrentHashMap代码中可以看出，它引入了一个“分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据key.hashCode()来决定把key放到哪个HashTable中。

在ConcurrentHashMap中，就是把Map分成了N个Segment，put和get的时候，都是现根据key.hashCode()算出放到哪个Segment中：