-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
corePoolSize：线程池中所保存的核心线程数，包括空闲线程
workQueue：任务执行前保存任务的队列，仅保存由 execute 方法提交的 Runnable 任务
maxPoolSize：池中允许的最大线程数。
keepAliveTime：线程池线程数量大于 corePoolSize 时，线程的空闲时间超过 keepAliveTime，就将其移除线程池
TimeUnit：持续时间的单位。
threadFactory：线程工厂，主要用来创建线程；
handler：表示当拒绝处理任务时的策略

1）ArrayBlockingQueue：基于数组的先进先出队列，此队列创建时必须指定大小；
2）LinkedBlockingQueue：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为Integer.MAX_VALUE；
3）synchronousQueue：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。

-----------------------------------------------------------------------------------------------------------------------------------
1.corePoolSize 创建满
2.workQueue 满
3.程数<maxPoolSize 创建线程
4.程数>maxPoolSize 线程拒绝策略
5.RejectedExecutionHandler（饱和策略）
	ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 
	ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
	ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
	ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
	RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。
keepAliveTime线程回收
-----------------------------------------------------------------------------------------------------------------------------------

常用的几种线程池
newCachedThreadPool
创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
newFixedThreadPool
创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。
newSingleThreadExecutor
创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务
-----------------------------------------------------------------------------------------------------------------------------------

execute()  Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现,向线程池提交一个任务，交由线程池去执行
submit()   ExecutorService中声明的方法,能够返回任务执行的结果,利用Future
shutdown()：不会立即终止线程池，任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务
shutdownNow()：立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务