-----------------------------------------------------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------------------------------------------------
synchronized:
1.用在代码块：synchronized(obj){//todo code here}
2. public void test() {
     synchronized(this) {
          // todo your code
     }
	等同于public synchronized void test()


-----------------------------------------------------------------------------------------------------------------------------------

A．用在方法签名上，会获取该实例的对象锁，不会阻塞其它对象。用到类方法上饰符为static， 该类的锁，会阻塞其它对象

B．每个对象只有一个锁（lock）与之相关联。

C．实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。

D. synchronized关键字是不能继承的,基类的方法synchronized f(){} 在继承类中并不自动是synchronized.需要显式的指定

-----------------------------------------------------------------------------------------------------------------------------------

1、线程同步的目的是为了保护多个线程反问一个资源时对资源的破坏。

2、线程同步方法是通过锁来实现，每个对象都有切仅有一个锁，线程一旦获取了对象锁，其他访问该对象的线程就无法再访问该对象的其他非同步方法。

3、对于静态同步方法，锁是针对这个类的，锁对象是该类的Class对象。静态和非静态方法的锁互不干预。一个线程获得锁，当在一个同步方法中访问另外对象上的同步方法时，会获取这两个对象锁。

4、对于同步，要时刻清醒在哪个对象上同步，这是关键。

5、编写线程安全的类，需要时刻注意对多个线程竞争访问资源的逻辑和安全做出正确的判断，对“原子”操作做出分析，并保证原子操作期间别的线程无法访问竞争资源。

6、当多个线程等待一个对象锁时，没有获取到锁的线程将发生阻塞。

7、死锁是线程间相互等待锁锁造成的。

-----------------------------------------------------------------------------------------------------------------------------------


