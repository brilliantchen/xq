-----------------------------------------------------------------------------------------------------------------------------------
乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性（不能解决脏读）Lock
悲观锁：假定会发生并发冲突，独占和排他特性，synchronized

数据库层次，version版本号，for update

悲观锁，在线程挂起和恢复执行过程中存在着很大的开销，
悲观锁，线程可以不让出cpu,而是一直while循环，如果失败就重试，直到成功为止。所以，当数据争用不严重时，乐观锁效果更好。
CAS实现：ABA问题，AtomicStampedReference和AtomicMarkableReference支持在两个变量上执行原子的条件更新。AtomicStampedReference更新一个“对象-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题，AtomicMarkableReference将更新一个“对象引用-布尔值”的二元组。

-----------------------------------------------------------------------------------------------------------------------------------
JDK1.6后

1.偏向锁：-XX:+UseBiasedLocking （打开）  -XX:-UseBiastedLocking（禁用）
偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。
如果程序没有竞争，则取消之前已经取得锁的线程同步操作（工作内存线程内存的同步），
若某一锁被线程获取后，便进入偏向模式，当线程再次请求这个锁时，就无需再进行相关的同步操作了，从而节约了操作时间
如果在此之间有其他的线程进行了锁请求，则锁退出偏向模式。
偏向锁在锁竞争激烈的场合没有太强的优化效果，反而有可能降低系统的性能。

2.轻量级锁 CAS
如果偏向锁失败，Java虚拟机就会让线程申请轻量级锁

3.重量级锁 Synchronized
当轻量级锁失败，虚拟机就会使用重量级锁


4.自旋锁
自旋锁可以使线程在没有取得锁的时候，不被挂起，而转去执行一个空循环，（即所谓的自旋，就是自己执行空循环），若在若干个空循环后，线程如果可以获得锁，则继续执行。若线程依然不能获得锁，才会被挂起。
适合锁竞争不是很激烈，锁占用时间很短的并发线程

在JDK1.6中，Java虚拟机提供-XX:+UseSpinning参数来开启自旋锁，使用-XX:PreBlockSpin参数来设置自旋锁等待的次数。
在JDK1.7开始，自旋锁的参数被取消，虚拟机不再支持由用户配置自旋锁，自旋锁总是会执行，自旋锁次数也由虚拟机自动调整。